#!/usr/bin/env python3
"""
This script parses a JSON file (expected to be in the format generated by the Yocto build)
and aggregates the statuses of the vulnerabilities or CVEs.
Usage:
    python check_yocto_cve_json.py path/to/core-image-base-raspberrypi4-64.json [--config path/to/config.json]
"""

import json
import sys
import argparse

def extract_packages(data) -> list:
    if not isinstance(data, dict):
        print("Invalid data format: data is not dict.")
    packages = data["package"]
    if not isinstance(packages, list):
        print("Invalid data format: package is not list.")
        return None
    return packages

def check_issues(issues) -> dict:
    vul_counts = {
        "Ignored": 0,
        "Patched": 0,
        "Unpatched": 0,
        "Unknown": 0,
    }
    for issue in issues:
        if issue["status"] == "Ignored":
            vul_counts["Ignored"] += 1
        elif issue["status"] == "Patched":
            vul_counts["Patched"] += 1
        elif issue["status"] == "Unpatched":
            vul_counts["Unpatched"] += 1
        else:
            vul_counts["Unknown"] += 1
    return vul_counts

def search_unpatched_issues(issues) -> list:
    # Return list of unpatched issue IDs.
    unpatched_issue_id_list = []
    for issue in issues:
        if issue["status"] == "Unpatched":
            unpatched_issue_id_list.append(issue["id"])
    return unpatched_issue_id_list

def check_cve_by_package(package) -> dict:
    if not isinstance(package, dict):
        print("Invalid data format: each package is not dict.")
        return None
    issues = package["issue"]
    unpatched_issues = search_unpatched_issues(issues)
    result_package = package
    result_package.pop("issue")
    result_package["unpatched_issues"] = unpatched_issues
    return result_package

def check_unpatched_packages(result_packages, exclude_list=[]) -> list:
    unpatched_package_name_list = []
    for package in result_packages:
        if package.get("name") in exclude_list:
            continue
        if len(package.get("unpatched_issues", [])) != 0:
            print(package["name"] + " has unpatched issue:" + str(package["unpatched_issues"]))
            unpatched_package_name_list.append(package["name"])
    return unpatched_package_name_list

def main(json_filepath, config_filepath=None):
    config = {}
    if config_filepath:
        try:
            with open(config_filepath, 'r') as cf:
                config = json.load(cf)
            print(f"Loaded configuration from {config_filepath}")
        except Exception as e:
            print(f"Error reading config file: {e}")
            sys.exit(1)
    try:
        with open(json_filepath, 'r') as json_file:
            data = json.load(json_file)
    except Exception as e:
        print(f"Error reading JSON file: {e}")
        sys.exit(1)

    checked_packages = []
    packages = extract_packages(data)
    for package in packages:
        checked_packages.append(check_cve_by_package(package))

    exclude_list = config.get("exclude_packages", []) if config else []
    unpatched_packages = check_unpatched_packages(checked_packages, exclude_list)
    print("================================================================")
    if len(unpatched_packages) == 0:
        print("unpatched package is not found.")
    else:
        print("your software's dependency has unpatched package.")
        print("please check packages: " + str(unpatched_packages))
        sys.exit(1)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="Check Yocto CVE JSON and optionally load a config file")
    parser.add_argument("json_filepath", help="Path to the JSON file to check")
    parser.add_argument("--config", dest="config_filepath", help="Optional config file path", default=None)
    args = parser.parse_args()
    main(args.json_filepath, args.config_filepath)
